#pragma kernel Hash
#pragma kernel Sort
#pragma kernel CalculateLookupStartIndexes

struct LookupTableType
{
    uint index;
    uint hash;
};

shared RWStructuredBuffer<LookupTableType> LookupTable;
shared RWStructuredBuffer<uint> StartLookupIndexes;
const uint groupWidth;
const uint groupHeight;
const uint stepIndex;

#include "./hash.hlsl"
StructuredBuffer<float2> positions;
const float4 box_size;
const float interaction_radius;
const float2 cell_size;
const uint hashCount;
const uint totalNumberOfParticles;

// Create Hashes
[numthreads(128, 1, 1)]
void Hash(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= totalNumberOfParticles) return;
    // Update LookupTable
    // Every particles is assigned pair (index, hash)
    uint cellHash = HashFromPos(positions[id.x], box_size.xy, cell_size, hashCount);
    LookupTable[id.x].index = id.x;
    LookupTable[id.x].hash  = cellHash;

    // Reset StartLookupIndexes
    StartLookupIndexes[id.x] = totalNumberOfParticles;
}

// Sort the given entries by their keys (smallest to largest)
// This is done using bitonic merge sort, and takes multiple iterations
[numthreads(128, 1, 1)]
void Sort(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    uint hIndex = i & (groupWidth - 1);
    uint indexLeft = hIndex + (groupHeight + 1) * (i / groupWidth);
    uint rightStepSize = stepIndex == 0 ? groupHeight - 2 * hIndex : (groupHeight + 1) / 2;
    uint indexRight = indexLeft + rightStepSize;

    // Exit if out of bounds (for non-power of 2 input sizes)
    if (indexRight >= totalNumberOfParticles) return;

    uint valueLeft = LookupTable[indexLeft].hash;
    uint valueRight = LookupTable[indexRight].hash;

    // Swap entries if value is descending
    if (valueLeft > valueRight)
    {
        LookupTableType temp = LookupTable[indexLeft];
        LookupTable[indexLeft] = LookupTable[indexRight];
        LookupTable[indexRight] = temp;
    }
}

// Calculate offsets into the sorted Entries buffer (used for spatial hashing).
// For example, given an Entries buffer sorted by key like so: {2, 2, 2, 3, 6, 6, 9, 9, 9, 9}
// The resulting Offsets calculated here should be:            {-, -, 0, 3, -, -, 4, -, -, 6}
// (where '-' represents elements that won't be read/written)
//
// Usage example:
// Say we have a particular particle P, and we want to know which particles are in the same grid cell as it.
// First we would calculate the Key of P based on its position. Let's say in this example that Key = 9.
// Next we can look up Offsets[Key] to get: Offsets[9] = 6
// This tells us that SortedEntries[6] is the first particle that's in the same cell as P.
// We can then loop until we reach a particle with a different cell key in order to iterate over all the particles in the cell.
//
// NOTE: offsets buffer must filled with values equal to (or greater than) its length to ensure that this works correctly


[numthreads(128, 1, 1)]
void CalculateLookupStartIndexes(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= totalNumberOfParticles) return;

    uint i = id.x;
    uint null = totalNumberOfParticles;

    uint hash = LookupTable[i].hash;
    uint hashPrev = i == 0 ? null : LookupTable[i - 1].hash;

    if (hash != hashPrev)
    {
        StartLookupIndexes[hash] = i;
    }
}